#ifndef __FLEXSPI_IMX8_H
#define __FLEXSPI_IMX8_H

/* Peripheral CCM base address */
#define CCM_BASE		0x30380000
#define CCM_CCGR47		0x42F0
#define QSPI_CLK_ROOT	0xAB80
#define CLK_ROOT_EN		BIT(28)
#define MUX_CLK_ROOT_SELECT(x)	((x) << 24)
#define PRE_PODF(x)		((x) << 16)
#define POST_PODF(x)		((x) << 0)

/**Peripheral FLEXSPI base address */
#define FLEXSPI_BASE	0x30BB0000
static volatile u32 __iomem *flexspi_base = NULL;

#define FSL_FEATURE_FlexSPI_AHB_BUFFER_COUNT	8
typedef struct {
	uint32_t MCR0;								
	uint32_t MCR1;								
	uint32_t MCR2;								
	uint32_t AHBCR;								
	uint32_t INTEN;								
	uint32_t INTR;								
	uint32_t LUTKEY;							
	uint32_t LUTCR;								
	uint32_t AHBRXBUFCR0[8];					
	uint8_t RESERVED_0[32];
	uint32_t FLSHCR0[4];						
	uint32_t FLSHCR1[4];						
	uint32_t FLSHCR2[4];						
	uint8_t RESERVED_1[4];
	uint32_t FLSHCR4;							
	uint8_t RESERVED_2[8];
	uint32_t IPCR0;								
	uint32_t IPCR1;								
	uint8_t RESERVED_3[8];
	uint32_t IPCMD;								
	uint32_t DLPR;								
	uint32_t IPRXFCR;							
	uint32_t IPTXFCR;							
	uint32_t DLLCR[2];							
	uint8_t RESERVED_4[24];
	uint32_t STS0;								
	uint32_t STS1;								
	uint32_t STS2;								
	uint32_t AHBSPNDSTS;						
	uint32_t IPRXFSTS;							
	uint32_t IPTXFSTS;							
	uint8_t RESERVED_5[8];
	uint32_t RFDR[32];							
	uint32_t TFDR[32];							
	uint32_t LUT[128];							
} FlexSPI_Type;

/*! @brief FLEXSPI sample clock source selection for Flash Reading.*/
typedef enum _flexspi_read_sample_clock
{
	kFlexSPI_ReadSampleClkLoopbackInternally = 0x0U,	  /*!< Dummy Read strobe generated by FlexSPI Controller
															   and loopback internally. */
	kFlexSPI_ReadSampleClkLoopbackFromDqsPad = 0x1U,	  /*!< Dummy Read strobe generated by FlexSPI Controller
															   and loopback from DQS pad. */
	kFlexSPI_ReadSampleClkLoopbackFromSckPad	  = 0x2U, /*!< SCK output clock and loopback from SCK pad. */
	kFlexSPI_ReadSampleClkExternalInputFromDqsPad = 0x3U, /*!< Flash provided Read strobe and input from DQS pad. */
} flexspi_read_sample_clock_t;

typedef struct _flexspi_ahbBuffer_config
{
	uint8_t priority;	 /*!< This priority for AHB Master Read which this AHB RX Buffer is assigned. */
	uint8_t masterIndex; /*!< AHB Master ID the AHB RX Buffer is assigned. */
	uint16_t bufferSize; /*!< AHB buffer size in byte. */
	bool enablePrefetch; /*!< AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master, allows
						  prefetch disable/enable separately for each master. */
} flexspi_ahbBuffer_config_t;

/*! @brief FLEXSPI interval unit for flash device select.*/
typedef enum _flexspi_cs_interval_cycle_unit
{
	kFlexSPI_CsIntervalUnit1SckCycle   = 0x0U, /*!< Chip selection interval: CSINTERVAL * 1 serial clock cycle. */
	kFlexSPI_CsIntervalUnit256SckCycle = 0x1U, /*!< Chip selection interval: CSINTERVAL * 256 serial clock cycle. */
} flexspi_cs_interval_cycle_unit_t;

/*! @brief FLEXSPI AHB wait interval unit for writing.*/
typedef enum _flexspi_ahb_write_wait_unit
{
	kFlexSPI_AhbWriteWaitUnit2AhbCycle	   = 0x0U, /*!< AWRWAIT unit is 2 ahb clock cycle. */
	kFlexSPI_AhbWriteWaitUnit8AhbCycle	   = 0x1U, /*!< AWRWAIT unit is 8 ahb clock cycle. */
	kFlexSPI_AhbWriteWaitUnit32AhbCycle    = 0x2U, /*!< AWRWAIT unit is 32 ahb clock cycle. */
	kFlexSPI_AhbWriteWaitUnit128AhbCycle   = 0x3U, /*!< AWRWAIT unit is 128 ahb clock cycle. */
	kFlexSPI_AhbWriteWaitUnit512AhbCycle   = 0x4U, /*!< AWRWAIT unit is 512 ahb clock cycle. */
	kFlexSPI_AhbWriteWaitUnit2048AhbCycle  = 0x5U, /*!< AWRWAIT unit is 2048 ahb clock cycle. */
	kFlexSPI_AhbWriteWaitUnit8192AhbCycle  = 0x6U, /*!< AWRWAIT unit is 8192 ahb clock cycle. */
	kFlexSPI_AhbWriteWaitUnit32768AhbCycle = 0x7U, /*!< AWRWAIT unit is 32768 ahb clock cycle. */
} flexspi_ahb_write_wait_unit_t;

/*! @brief FLEXSPI operation port select.*/
typedef enum _flexspi_port
{
	kFlexSPI_PortA1 = 0x0U, /*!< Access flash on A1 port. */
	kFlexSPI_PortA2,		/*!< Access flash on A2 port. */
	kFlexSPI_PortB1,		/*!< Access flash on B1 port. */
	kFlexSPI_PortB2,		/*!< Access flash on B2 port. */
	kFlexSPI_PortCount
} flexspi_port_t;

/*! @brief pad definition of FLEXSPI, use to form LUT instruction. */
typedef enum _flexspi_pad
{
	kFlexSPI_1PAD = 0x00U, /*!< Transmit command/address and transmit/receive data only through DATA0/DATA1. */
	kFlexSPI_2PAD = 0x01U, /*!< Transmit command/address and transmit/receive data only through DATA[1:0]. */
	kFlexSPI_4PAD = 0x02U, /*!< Transmit command/address and transmit/receive data only through DATA[3:0]. */
	kFlexSPI_8PAD = 0x03U, /*!< Transmit command/address and transmit/receive data only through DATA[7:0]. */
} flexspi_pad_t;

/*! @brief FLEXSPI configuration structure. */
typedef struct _flexspi_config
	{
	flexspi_read_sample_clock_t rxSampleClock; /*!< Sample Clock source selection for Flash Reading. */
	bool enableSckFreeRunning;				   /*!< Enable/disable SCK output free-running. */
	bool enableCombination;					   /*!< Enable/disable combining PORT A and B Data Pins
											   (SIOA[3:0] and SIOB[3:0]) to support Flash Octal mode. */
	bool enableDoze;						   /*!< Enable/disable doze mode support. */
	bool enableHalfSpeedAccess;				   /*!< Enable/disable divide by 2 of the clock for half
												speed commands. */
	bool enableSckBDiffOpt;					   /*!< Enable/disable SCKB pad use as SCKA differential clock
												output, when enable, Port B flash access is not available. */
	bool enableSameConfigForAll;			   /*!< Enable/disable same configuration for all connected devices
												when enabled, same configuration in FLASHA1CRx is applied to all. */
	uint16_t seqTimeoutCycle;				   /*!< Timeout wait cycle for command sequence execution,
											   timeout after ahbGrantTimeoutCyle*1024 serial root clock cycles. */
	uint8_t ipGrantTimeoutCycle;			   /*!< Timeout wait cycle for IP command grant, timeout after
												ipGrantTimeoutCycle*1024 AHB clock cycles. */
	uint8_t txWatermark;					   /*!< FLEXSPI IP transmit watermark value. */
	uint8_t rxWatermark;					   /*!< FLEXSPI receive watermark value. */
	struct
	{
		uint8_t ahbGrantTimeoutCycle; /*!< Timeout wait cycle for AHB command grant,
									   timeout after ahbGrantTimeoutCyle*1024 AHB clock cycles. */
		uint16_t ahbBusTimeoutCycle;  /*!< Timeout wait cycle for AHB read/write access,
									  timeout after ahbBusTimeoutCycle*1024 AHB clock cycles. */
		uint8_t resumeWaitCycle;	  /*!< Wait cycle for idle state before suspended command sequence
									   resume, timeout after ahbBusTimeoutCycle AHB clock cycles. */
		flexspi_ahbBuffer_config_t buffer[FSL_FEATURE_FlexSPI_AHB_BUFFER_COUNT]; /*!< AHB buffer size. */
		bool enableClearAHBBufferOpt; /*!< Enable/disable automatically clean AHB RX Buffer and TX Buffer
									   when FLEXSPI returns STOP mode ACK. */
		bool enableReadAddressOpt;	  /*!< Enable/disable remove AHB read burst start address alignment limitation.
									   when enable, there is no AHB read burst start address alignment limitation. */
		bool enableAHBPrefetch;		  /*!< Enable/disable AHB read prefetch feature, when enabled, FLEXSPI
									   will fetch more data than current AHB burst. */
		bool enableAHBBufferable;	  /*!< Enable/disable AHB bufferable write access support, when enabled,
									   FLEXSPI return before waiting for command execution finished. */
		bool enableAHBCachable;		  /*!< Enable AHB bus cachable read access support. */
	} ahbConfig;
} flexspi_config_t;

/*! @brief Root clock select enumeration for QSPI peripheral. */
typedef enum _clock_rootmux_qspi_clk_sel
{
	kCLOCK_QspiRootmuxOsc24M	  = 0U, /* ARM QSPI Clock from OSC 24M. */
	kCLOCK_QspiRootmuxSysPll1Div2 = 1U, /* ARM QSPI Clock from SYSTEM PLL1 divided by 2, 400MHz */
	kCLOCK_QspiRootmuxSysPll2Div3 = 2U, /* ARM QSPI Clock from SYSTEM PLL2 divided by 3, 333MHz */
	kCLOCK_QspiRootmuxSysPll2Div2 = 3U, /* ARM QSPI Clock from SYSTEM PLL2 divided by 2, 500MHz */
	kCLOCK_QspiRootmuxAudioPll2   = 4U, /* ARM QSPI Clock from AUDIO PLL2, 650MHz */
	kCLOCK_QspiRootmuxSysPll1Div3 = 5U, /* ARM QSPI Clock from SYSTEM PLL1 divided by 3, 266MHz */
	kCLOCK_QspiRootmuxSysPll3	  = 6U, /* ARM QSPI Clock from SYSTEM PLL3, 1000MHz */
	kCLOCK_QspiRootmuxSysPll1Div8 = 7U, /* ARM QSPI Clock from SYSTEM PLL1 divided by 8, 100MHz */
} clock_rootmux_qspi_clk_sel_t;


/* Registers used by the driver */
#define FSPI_MCR0		0x00
#define FSPI_MCR0_AHB_TIMEOUT(x)	((x) << 24)
#define FSPI_MCR0_IP_TIMEOUT(x)		((x) << 16)
#define FSPI_MCR0_LEARN_EN		BIT(15)
#define FSPI_MCR0_SCRFRUN(x)	((x) << 14)
#define FSPI_MCR0_OCTCOMB(x)	((x) << 13)
#define FSPI_MCR0_DOZE_EN		BIT(12)
#define FSPI_MCR0_HSEN			BIT(11)
#define FSPI_MCR0_SERCLKDIV		BIT(8)
#define FSPI_MCR0_ATDF_EN		BIT(7)
#define FSPI_MCR0_ARDF_EN		BIT(6)
#define FSPI_MCR0_RXCLKSRC(x)	((x) << 4)
#define FSPI_MCR0_END_CFG(x)	((x) << 2)
#define FSPI_MCR0_MDIS			BIT(1)
#define FSPI_MCR0_SWRST			BIT(0)

#define FSPI_MCR1		0x04
#define FSPI_MCR1_SEQ_TIMEOUT(x)	((x) << 16)
#define FSPI_MCR1_AHB_TIMEOUT(x)	(x)

#define FSPI_MCR2		0x08
#define FSPI_MCR2_RESUMEWAIT(x)		((x) << 24)
#define FSPI_MCR2_SCKBDIFFOPT(x)	((x) << 19)

#define FSPI_MCR2_SAMEDEVICE(x)		((x) << 15)
#define FSPI_MCR2_CLRLRPHS			BIT(14)
#define	FSPI_MCR2_CLRAHBBUFOPT(x)	((x) << 11)

#define FSPI_AHBCR		0x0c
#define FSPI_AHBCR_RDADDROPT(x)		((x) << 6)
#define	FSPI_AHBCR_PREFETCHEN(x)	((x) << 5)
#define FSPI_AHBCR_BUFFERABLEEN(x)	((x) << 4)
#define FSPI_AHBCR_CACHABLEEN(x)	((x) << 3)
#define FSPI_AHBCR_PAR_EN			BIT(0)

#define FSPI_AHBRXBUFCR0_PREFETCHEN(x)	((x) << 31)
#define FSPI_AHBRXBUFCR0_PRIORITY(x)	((x) << 24)
#define FSPI_AHBRXBUFCR0_MSTRID(x)		((x) << 16)
#define FSPI_AHBRXBUFCR0_BUFSZ(x)		((x) << 0)

#define FLEXSPI_STS0_ARB_IDLE_SHIFT	1
#define FLEXSPI_STS0_ARB_IDLE_MASK	(1 << FLEXSPI_STS0_ARB_IDLE_SHIFT)
#define FLEXSPI_STS0_SEQ_IDLE_SHIFT	0
#define FLEXSPI_STS0_SEQ_IDLE_MASK	(1 << FLEXSPI_STS0_SEQ_IDLE_SHIFT)

#define FlexSPI_MCR0_SWRESET_MASK                (0x1U)
#define FlexSPI_MCR0_SWRESET_SHIFT               (0U)
#define FlexSPI_MCR0_MDIS_MASK                   (0x2U)
#define FlexSPI_MCR0_MDIS_SHIFT                  (1U)
#define FlexSPI_MCR0_RXCLKSRC_MASK               (0x30U)
#define FlexSPI_MCR0_RXCLKSRC_SHIFT              (4U)

#define FlexSPI_FLSHCR4_WMOPT1_MASK              (0x1U)
#define FlexSPI_FLSHCR4_WMOPT1_SHIFT             (0U)
#define FlexSPI_FLSHCR4_WMENA_MASK               (0x4U)
#define FlexSPI_FLSHCR4_WMENA_SHIFT              (2U)
#define FlexSPI_FLSHCR4_WMENB_MASK               (0x8U)
#define FlexSPI_FLSHCR4_WMENB_SHIFT              (3U)

#define FlexSPI_FLSHCR4_WMOPT1(x)                (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR4_WMOPT1_SHIFT)) & FlexSPI_FLSHCR4_WMOPT1_MASK)
#define FlexSPI_FLSHCR4_WMENA(x)                 (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR4_WMENA_SHIFT)) & FlexSPI_FLSHCR4_WMENA_MASK)
#define FlexSPI_FLSHCR4_WMENB(x)                 (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR4_WMENB_SHIFT)) & FlexSPI_FLSHCR4_WMENB_MASK)


#define FSPI_FLSHCR1_CSINTERVAL(x)		((x) << 16)
#define FSPI_FLSHCR1_CSINTERVALUNIT(x)	((x) << 15)
#define FSPI_FLSHCR1_CAS(x)				((x) << 11)
#define FSPI_FLSHCR1_WA(x)				((x) << 10)
#define FSPI_FLSHCR1_TCSH(x)			((x) << 5)
#define FSPI_FLSHCR1_TCSS(x)			((x) << 0)

#define FSPI_FLSHCR2_ARDSEQNUM(x)		((x) << 5)
#define FSPI_FLSHCR2_ARDSEQID(x)		((x) << 0)

#define FSPI_LUTKEY_VALUE		0x5AF05AF0
#define FSPI_LCKER_LOCK			0x1
#define FSPI_LCKER_UNLOCK		0x2


#define FlexSPI_FLSHCR2_ARDSEQID_MASK            (0x1FU)
#define FlexSPI_FLSHCR2_ARDSEQID_SHIFT           (0U)
#define FlexSPI_FLSHCR2_ARDSEQID(x)              (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR2_ARDSEQID_SHIFT)) & FlexSPI_FLSHCR2_ARDSEQID_MASK)
#define FlexSPI_FLSHCR2_ARDSEQNUM_MASK           (0xE0U)
#define FlexSPI_FLSHCR2_ARDSEQNUM_SHIFT          (5U)
#define FlexSPI_FLSHCR2_ARDSEQNUM(x)             (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR2_ARDSEQNUM_SHIFT)) & FlexSPI_FLSHCR2_ARDSEQNUM_MASK)
#define FlexSPI_FLSHCR2_AWRSEQID_MASK            (0x1F00U)
#define FlexSPI_FLSHCR2_AWRSEQID_SHIFT           (8U)
#define FlexSPI_FLSHCR2_AWRSEQID(x)              (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR2_AWRSEQID_SHIFT)) & FlexSPI_FLSHCR2_AWRSEQID_MASK)
#define FlexSPI_FLSHCR2_AWRSEQNUM_MASK           (0xE000U)
#define FlexSPI_FLSHCR2_AWRSEQNUM_SHIFT          (13U)
#define FlexSPI_FLSHCR2_AWRSEQNUM(x)             (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR2_AWRSEQNUM_SHIFT)) & FlexSPI_FLSHCR2_AWRSEQNUM_MASK)
#define FlexSPI_FLSHCR2_AWRWAIT_MASK             (0xFFF0000U)
#define FlexSPI_FLSHCR2_AWRWAIT_SHIFT            (16U)
#define FlexSPI_FLSHCR2_AWRWAIT(x)               (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR2_AWRWAIT_SHIFT)) & FlexSPI_FLSHCR2_AWRWAIT_MASK)
#define FlexSPI_FLSHCR2_AWRWAITUNIT_MASK         (0x70000000U)
#define FlexSPI_FLSHCR2_AWRWAITUNIT_SHIFT        (28U)
/*! AWRWAITUNIT - AWRWAIT unit
 *  0b000..The AWRWAIT unit is 2 ahb clock cycle
 *  0b001..The AWRWAIT unit is 8 ahb clock cycle
 *  0b010..The AWRWAIT unit is 32 ahb clock cycle
 *  0b011..The AWRWAIT unit is 128 ahb clock cycle
 *  0b100..The AWRWAIT unit is 512 ahb clock cycle
 *  0b101..The AWRWAIT unit is 2048 ahb clock cycle
 *  0b110..The AWRWAIT unit is 8192 ahb clock cycle
 *  0b111..The AWRWAIT unit is 32768 ahb clock cycle
 */
#define FlexSPI_FLSHCR2_AWRWAITUNIT(x)           (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR2_AWRWAITUNIT_SHIFT)) & FlexSPI_FLSHCR2_AWRWAITUNIT_MASK)
#define FlexSPI_FLSHCR2_CLRINSTRPTR_MASK         (0x80000000U)
#define FlexSPI_FLSHCR2_CLRINSTRPTR_SHIFT        (31U)
#define FlexSPI_FLSHCR2_CLRINSTRPTR(x)           (((uint32_t)(((uint32_t)(x)) << FlexSPI_FLSHCR2_CLRINSTRPTR_SHIFT)) & FlexSPI_FLSHCR2_CLRINSTRPTR_MASK)

/* The count of FlexSPI_FLSHCR2 */
#define FlexSPI_FLSHCR2_COUNT                    (4U)


#define FSPI_LUT_NUM	128

/* Instruction set for the LUT register */
#define LUT_STOP			0x00
#define LUT_CMD				0x01
#define LUT_ADDR			0x02
#define LUT_CADDR_SDR		0x03
#define LUT_CMD_SDR        0x01 /*!< Transmit Command code to Flash, using SDR mode. */
#define LUT_RADDR_SDR      0x02 /*!< Transmit Row Address to Flash, using SDR mode. */
#define LUT_CADDR_SDR      0x03 /*!< Transmit Column Address to Flash, using SDR mode. */
#define LUT_MODE1_SDR      0x04 /*!< Transmit 1-bit Mode bits to Flash, using SDR mode. */
#define LUT_MODE2_SDR      0x05 /*!< Transmit 2-bit Mode bits to Flash, using SDR mode. */
#define LUT_MODE4_SDR      0x06 /*!< Transmit 4-bit Mode bits to Flash, using SDR mode. */
#define LUT_MODE8_SDR      0x07 /*!< Transmit 8-bit Mode bits to Flash, using SDR mode. */
#define LUT_WRITE_SDR      0x08 /*!< Transmit Programming Data to Flash, using SDR mode. */
#define LUT_READ_SDR       0x09 /*!< Receive Read Data from Flash, using SDR mode. */
#define LUT_LEARN_SDR      0x0A /*!< Receive Read Data or Preamble bit from Flash, SDR mode. */
#define LUT_DATSZ_SDR      0x0B /*!< Transmit Read/Program Data size (byte) to Flash, SDR mode. */
#define LUT_DUMMY_SDR      0x0C /*!< Leave data lines undriven by FlexSPI controller.*/
#define LUT_DUMMY_RWDS_SDR 0x0DU, /*!< Leave data lines undriven by FlexSPI controller */
#define LUT_MODE			0x04
#define LUT_MODE2			0x05
#define LUT_MODE4			0x06
#define LUT_MODE8			0x07
#define LUT_NXP_WRITE		0x08
#define LUT_NXP_READ		0x09
#define LUT_LEARN_SDR		0x0A
#define LUT_DATSZ_SDR		0x0B
#define LUT_DUMMY			0x0C
#define LUT_JMP_ON_CS		0x1F
#define LUT_CMD_DDR			0x21
#define LUT_ADDR_DDR		0x22
#define LUT_CADDR_DDR		0x23
#define LUT_MODE_DDR		0x24
#define LUT_MODE2_DDR		0x25
#define LUT_MODE4_DDR		0x26
#define LUT_MODE8_DDR		0x27
#define LUT_WRITE_DDR		0x28
#define LUT_READ_DDR		0x29
#define LUT_LEARN_DDR		0x2A
#define LUT_DATSZ_DDR		0x2B
#define LUT_DUMMY_DDR		0x2C
#define LUT_DUMMY_RWDS_DDR	0x2D

#define FlexSPI_LUT_OPERAND0_MASK	(0xFFU)
#define FlexSPI_LUT_OPERAND0_SHIFT	(0U)
#define FlexSPI_LUT_OPERAND0(x)		(((u32)(((u32)(x)) << FlexSPI_LUT_OPERAND0_SHIFT)) & FlexSPI_LUT_OPERAND0_MASK)
#define FlexSPI_LUT_NUM_PADS0_MASK	(0x300U)
#define FlexSPI_LUT_NUM_PADS0_SHIFT	(8U)
#define FlexSPI_LUT_NUM_PADS0(x)	(((u32)(((u32)(x)) << FlexSPI_LUT_NUM_PADS0_SHIFT)) & FlexSPI_LUT_NUM_PADS0_MASK)
#define FlexSPI_LUT_OPCODE0_MASK	(0xFC00U)
#define FlexSPI_LUT_OPCODE0_SHIFT	(10U)
#define FlexSPI_LUT_OPCODE0(x)		(((u32)(((u32)(x)) << FlexSPI_LUT_OPCODE0_SHIFT)) & FlexSPI_LUT_OPCODE0_MASK)
#define FlexSPI_LUT_OPERAND1_MASK	(0xFF0000U)
#define FlexSPI_LUT_OPERAND1_SHIFT	(16U)
#define FlexSPI_LUT_OPERAND1(x)		(((u32)(((u32)(x)) << FlexSPI_LUT_OPERAND1_SHIFT)) & FlexSPI_LUT_OPERAND1_MASK)
#define FlexSPI_LUT_NUM_PADS1_MASK	(0x3000000U)
#define FlexSPI_LUT_NUM_PADS1_SHIFT	(24U)
#define FlexSPI_LUT_NUM_PADS1(x)	(((u32)(((u32)(x)) << FlexSPI_LUT_NUM_PADS1_SHIFT)) & FlexSPI_LUT_NUM_PADS1_MASK)
#define FlexSPI_LUT_OPCODE1_MASK	(0xFC000000U)
#define FlexSPI_LUT_OPCODE1_SHIFT	(26U)
#define FlexSPI_LUT_OPCODE1(x)		(((u32)(((u32)(x)) << FlexSPI_LUT_OPCODE1_SHIFT)) & FlexSPI_LUT_OPCODE1_MASK)

#define FlexSPI_LUT_SEQ(cmd0, pad0, op0, cmd1, pad1, op1) \
	(FlexSPI_LUT_OPERAND0(op0) | FlexSPI_LUT_NUM_PADS0(pad0) | FlexSPI_LUT_OPCODE0(cmd0) | FlexSPI_LUT_OPERAND1(op1) | \
	FlexSPI_LUT_NUM_PADS1(pad1) | FlexSPI_LUT_OPCODE1(cmd1))


#endif
